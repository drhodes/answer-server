// Copyright <2021> (see CONTRIBUTERS file)
// for license, see LICENSE file.

package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"

	"github.com/abbot/go-http-auth"
	"golang.org/x/crypto/bcrypt"
)

const version = "1.0.1"

var (
	secret   = flag.String("secret", "", "Default secret for use during testing")
	consumer = flag.String("consumer", "", "Default consumer")
	// host        = flag.String("host", "", "host name")
	// port        = flat.String("port", "", "port number")
	httpAddress = flag.String("https", "www.mathtech.org:5001", "Listen to")
)

func main() {
	flag.Parse()
	log.Printf("Lis %s, waiting request. v%s", *httpAddress, version)

	// these next two files are not included in the repository. At the
	// moment, they are manually generated by running a python script
	// against the acme.json file used by Traefik which was generated
	// by the let's encrypt registration process.

	keyFile := "./key.pem"
	certFile := "./certificate.pem"

	authenticator := auth.NewBasicAuthenticator(*httpAddress, secretPass)
	wrapper := authenticator.Wrap(handler)

	log.Fatal(http.ListenAndServeTLS(*httpAddress, certFile, keyFile, wrapper))
}

// This function is passed up to the authenticator library for
// authentication purposes.
func secretPass(user, realm string) string {
	if user == *consumer {
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(*secret), bcrypt.DefaultCost)
		if err == nil {
			return string(hashedPassword)
		}
	}
	return ""
}

func handler(w http.ResponseWriter, r *auth.AuthenticatedRequest) {
	// Grab the use userid and labname from the request.
	userid := r.FormValue("userid")
	labname := r.FormValue("labname")

	if userid == "" {
		fmt.Fprintf(w, `{"error": "userid missing from form data"}`)
	}
	if labname == "" {
		fmt.Fprintf(w, `{"error": "labname missing from form data"}`)
	}

	jsondata, err := GetAnswerData(userid, labname)
	if err != nil {
		fmt.Fprintf(w, `{"error": "%s"}`, err.Error())
	}

	fmt.Fprintf(w, "%s", jsondata)
}

// this definitely needs to change to work with kubernetes. Currently
// the jupyter notebook data is being reading from file in the user
// home directory.
func GetAnswerData(userid string, labName string) (string, error) {
	fmtStr := "/home/%s/%s"
	filename := fmt.Sprintf(fmtStr, strings.ToLower(userid), labName)
	bs, err := ioutil.ReadFile(filename)
	notebookData := string(bs)

	if err != nil {
		return "", errors.New("Couldn't find notebook data" + err.Error())
	} else {
		log.Println(notebookData)
		return notebookData, nil
	}
}
