// Copyright <2021> (see CONTRIBUTERS file)
// for license, see LICENSE file.

package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"

	"github.com/abbot/go-http-auth"
	"golang.org/x/crypto/bcrypt"
)

const version = "1.0.1"

var (
	secret   = flag.String("secret", "", "Default secret for use during testing")
	consumer = flag.String("consumer", "", "Default consumer")
	// host        = flag.String("host", "", "host name")
	// port        = flat.String("port", "", "port number")
	httpAddress = flag.String("https", "www.mathtech.org:5001", "Listen to")
)

func main() {
	flag.Parse()
	log.Printf("Lis %s, waiting request. v%s", *httpAddress, version)

	// these next two files are not included in the repository. At the
	// moment, they are manually generated by running a python script
	// against the acme.json file used by Traefik which was generated
	// by the let's encrypt registration process.

	keyFile := "./key.pem"
	certFile := "./certificate.pem"

	authenticator := auth.NewBasicAuthenticator(*httpAddress, secretPass)
	wrapper := authenticator.Wrap(handler)

	log.Fatal(http.ListenAndServeTLS(*httpAddress, certFile, keyFile, wrapper))
}

// This function is passed up to the authenticator library for
// authentication purposes.
func secretPass(user, realm string) string {
	if user == *consumer {
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(*secret), bcrypt.DefaultCost)
		if err == nil {
			return string(hashedPassword)
		}
	}
	return ""
}

func handler(w http.ResponseWriter, r *auth.AuthenticatedRequest) {
	// Grab the use userid and answerpath from the request.

	// userid will look like: jupyter-35dd7e9124c8847ec5-030ef
	userid := r.FormValue("userid")

	// example answerpath: jupyter-answer-magic/test/test_autograde1.json
	answerpath := r.FormValue("answerpath")


	// TODO this error handling needs to be done better.  there should
	// be an "ok" field for the client to check. for example:

	// if the answer data is found then return
	// {"ok": "true", "answerdata": "<...all the stuff...>"

	// otherwise
	// {"ok": "false", "error": "<reason for the failure>"}
	
	
	if userid == "" {
		fmt.Fprintf(w, `{"error": "userid missing from form data"}`)
	}
	if answerpath == "" {
		fmt.Fprintf(w, `{"error": "answerpath missing from form data"}`)
	}

	log.Println(r)
	jsondata, err := GetAnswerData(userid, answerpath)
	if err != nil {
		fmt.Fprintf(w, `{"error": "%s"}`, err.Error())
	}
	fmt.Fprintf(w, "%s", jsondata)
}

// this definitely needs to change to work with kubernetes. Currently
// the jupyter notebook data is being reading from file in the user
// home directory.
func GetAnswerData(userid string, labName string) (string, error) {
	log.Println("GettingAnswerData")
	log.Println(userid)
	log.Println(labName)
	fmtStr := "/home/%s/%s"
	filename := fmt.Sprintf(fmtStr, strings.ToLower(userid), labName)
	bs, err := ioutil.ReadFile(filename)
	answerData := string(bs)

	if err != nil {
		return "", errors.New("Couldn't find answer data" + err.Error())
	} else {
		log.Println(answerData)
		return answerData, nil
	}
}

// ------------------------------------------------------------------
// data store.
//

/*
   flat files

   ./student-answers/userid/labname/file.json

*/
